// ABOUTME: Interactive setup subcommand for first-time configuration
// ABOUTME: Detects runtimes, guides user through config, generates config file

package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/harper/acp-relay/internal/runtime"
	"github.com/harper/acp-relay/internal/xdg"
)

func runSetup() {
	fmt.Println("acp-relay setup - Interactive Configuration")
	fmt.Println("==========================================")
	fmt.Println()

	reader := bufio.NewReader(os.Stdin)

	// Step 1: Runtime Detection
	fmt.Println("Step 1: Detecting container runtimes...")
	fmt.Println()

	allRuntimes := runtime.DetectAll()
	availableRuntimes := []runtime.RuntimeInfo{}

	for _, rt := range allRuntimes {
		fmt.Printf("  %s: %s", rt.Name, rt.Status)
		if rt.Version != "" {
			fmt.Printf(" (v%s)", rt.Version)
		}
		if rt.SocketPath != "" {
			fmt.Printf(" @ %s", rt.SocketPath)
		}
		fmt.Println()

		if rt.Status == "available" || rt.Status == "running" {
			availableRuntimes = append(availableRuntimes, rt)
		}
	}
	fmt.Println()

	if len(availableRuntimes) == 0 {
		fmt.Println("❌ No container runtimes found!")
		fmt.Println()
		fmt.Println("Please install Docker or Colima:")
		fmt.Println("  Docker: https://docs.docker.com/get-docker/")
		fmt.Println("  Colima: brew install colima")
		os.Exit(1)
	}

	// Step 2: Runtime Selection
	var selectedRuntime runtime.RuntimeInfo

	if len(availableRuntimes) == 1 {
		selectedRuntime = availableRuntimes[0]
		fmt.Printf("✓ Auto-selected %s (only available runtime)\n", selectedRuntime.Name)
	} else {
		fmt.Println("Multiple runtimes available. Which would you like to use?")
		for i, rt := range availableRuntimes {
			fmt.Printf("  %d) %s (%s)\n", i+1, rt.Name, rt.Status)
		}
		fmt.Print("\nSelection [1]: ")

		input, err := reader.ReadString('\n')
		if err != nil {
			fmt.Printf("Error reading input: %v\n", err)
			os.Exit(1)
		}
		input = strings.TrimSpace(input)

		if input == "" || input == "1" {
			selectedRuntime = availableRuntimes[0]
		} else {
			// Parse selection
			var choice int
			fmt.Sscanf(input, "%d", &choice)
			if choice < 1 || choice > len(availableRuntimes) {
				fmt.Println("Invalid selection")
				os.Exit(1)
			}
			selectedRuntime = availableRuntimes[choice-1]
		}
		fmt.Printf("✓ Selected %s\n", selectedRuntime.Name)
	}
	fmt.Println()

	// Step 3: Path Configuration
	fmt.Println("Step 3: Path configuration...")
	fmt.Println()

	dataPath := xdg.DataHome()
	fmt.Printf("Data directory [%s]: ", dataPath)
	input, err := reader.ReadString('\n')
	if err != nil {
		fmt.Printf("Error reading input: %v\n", err)
		os.Exit(1)
	}
	input = strings.TrimSpace(input)
	if input != "" {
		dataPath = input
	}
	fmt.Printf("✓ Data directory: %s\n", dataPath)
	fmt.Println()

	configPath := filepath.Join(xdg.ConfigHome(), "config.yaml")
	fmt.Printf("Config file [%s]: ", configPath)
	input, err = reader.ReadString('\n')
	if err != nil {
		fmt.Printf("Error reading input: %v\n", err)
		os.Exit(1)
	}
	input = strings.TrimSpace(input)
	if input != "" {
		configPath = input
	}
	fmt.Printf("✓ Config file: %s\n", configPath)
	fmt.Println()

	// Step 4: Verbosity Preference
	fmt.Print("Enable verbose logging? [y/N]: ")
	input, err = reader.ReadString('\n')
	if err != nil {
		fmt.Printf("Error reading input: %v\n", err)
		os.Exit(1)
	}
	input = strings.TrimSpace(strings.ToLower(input))
	verboseLogging := input == "y" || input == "yes"
	if verboseLogging {
		fmt.Println("✓ Verbose logging enabled")
	} else {
		fmt.Println("✓ Verbose logging disabled")
	}
	fmt.Println()

	// Step 5: Generate Config
	fmt.Println("Step 5: Generating configuration...")
	fmt.Println()

	configContent := generateConfig(selectedRuntime, dataPath, verboseLogging)

	// Create config directory
	configDir := filepath.Dir(configPath)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		fmt.Printf("❌ Failed to create config directory: %v\n", err)
		os.Exit(1)
	}

	// Write config file
	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		fmt.Printf("❌ Failed to write config file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("✓ Config written to %s\n", configPath)
	fmt.Println()

	// Step 6: Success
	fmt.Println("==========================================")
	fmt.Println("✅ Setup complete!")
	fmt.Println()
	fmt.Println("Next steps:")
	fmt.Printf("  1. Review config: %s\n", configPath)
	fmt.Printf("  2. Start server:  acp-relay --config %s\n", configPath)
	fmt.Println()
}

func generateConfig(rt runtime.RuntimeInfo, dataPath string, verbose bool) string {
	dbPath := filepath.Join(dataPath, "db.sqlite")
	workspacePath := filepath.Join(dataPath, "workspaces")

	config := fmt.Sprintf(`# acp-relay configuration
# Generated by: acp-relay setup

server:
  http_port: 8080
  http_host: "0.0.0.0"
  websocket_port: 8081
  websocket_host: "0.0.0.0"
  management_port: 8082
  management_host: "127.0.0.1"

agent:
  command: "/usr/local/bin/mcp-agent"  # Update this path to your agent binary
  mode: "container"
  args: []
  env:
    ANTHROPIC_API_KEY: "${ANTHROPIC_API_KEY}"  # Set this in your environment

  container:
    image: "acp-relay-agent:latest"
    docker_host: "unix://%s"
    network_mode: "bridge"
    memory_limit: "512m"
    cpu_limit: 1.0
    workspace_host_base: "%s"
    workspace_container_path: "/workspace"
    auto_remove: true
    startup_timeout_seconds: 10

database:
  path: "%s"
`, rt.SocketPath, workspacePath, dbPath)

	return config
}
